# -*- coding: mbcs -*-
typelib_path = 'C:\\Program Files (x86)\\IVI Foundation\\IVI\\Bin\\IviDriverTypeLib.dll'
_lcid = 0 # change this if required
from ctypes import *
import comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0
from comtypes import GUID
from comtypes import BSTR
from ctypes import HRESULT
from comtypes import helpstring
from comtypes import COMMETHOD
from comtypes import dispid
from ctypes.wintypes import VARIANT_BOOL


class IIviComponentIdentity(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    'IVI Driver component identity interface'
    _iid_ = GUID('{47ED5185-A398-11D4-BA58-000064657374}')
    _idlflags_ = ['oleautomation']
class IIviDriverIdentity(IIviComponentIdentity):
    _case_insensitive_ = True
    'IVI Driver driver identity interface'
    _iid_ = GUID('{47ED5186-A398-11D4-BA58-000064657374}')
    _idlflags_ = ['oleautomation']
IIviComponentIdentity._methods_ = [
    COMMETHOD(['propget', helpstring('A brief description of the implementing component.  Description is limted to 256 bytes.')], HRESULT, 'Description',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
    COMMETHOD(['propget', helpstring('The revision of the implementing component.  Refer to IVI-3.2, Section 3.1.2.2, for a description of revision syntax and semantics.  Revision is limited to 256 bytes.')], HRESULT, 'Revision',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
    COMMETHOD(['propget', helpstring('The name of the vendor that supplies the implementing component.  Vendor is limited to 256 bytes.')], HRESULT, 'Vendor',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
]
################################################################
## code template for IIviComponentIdentity implementation
##class IIviComponentIdentity_Impl(object):
##    @property
##    def Description(self):
##        'A brief description of the implementing component.  Description is limted to 256 bytes.'
##        #return pVal
##
##    @property
##    def Revision(self):
##        'The revision of the implementing component.  Refer to IVI-3.2, Section 3.1.2.2, for a description of revision syntax and semantics.  Revision is limited to 256 bytes.'
##        #return pVal
##
##    @property
##    def Vendor(self):
##        'The name of the vendor that supplies the implementing component.  Vendor is limited to 256 bytes.'
##        #return pVal
##

IIviDriverIdentity._methods_ = [
    COMMETHOD(['propget', helpstring('The name of the manufacturer reported by the physical instrument.  If Simulation is enabled or the instrument is not capable of reporting the name of the manufacturer, a string is returned that explains the condition. Manufacturer is limited to 256 bytes')], HRESULT, 'InstrumentManufacturer',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
    COMMETHOD(['propget', helpstring('The model number or name reported by the physical instrument.  If Simulation is enabled or the instrument is not capable of reporting the model number or name, a string is returned that explains the condition.  Model is limited to 256 bytes')], HRESULT, 'InstrumentModel',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
    COMMETHOD(['propget', helpstring('The firmware revision reported by the physical instrument.  If Simulation is enabled or the instrument is not capable of reporting the firmware revision, a string is returned that explains the condition.')], HRESULT, 'InstrumentFirmwareRevision',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
    COMMETHOD(['propget', helpstring('The case-sensitive unique identifier of the implementing IVI-COM instrument driver.')], HRESULT, 'Identifier',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
    COMMETHOD(['propget', helpstring('A comma-separated list of instrument models that the IVI specific driver can control.')], HRESULT, 'SupportedInstrumentModels',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
    COMMETHOD(['propget', helpstring('For IVI class-compliant drivers, the major version number of the instrument class specification.  If the driver is not class compliant, the driver returns zero.')], HRESULT, 'SpecificationMajorVersion',
              ( ['out', 'retval'], POINTER(c_int), 'pVal' )),
    COMMETHOD(['propget', helpstring('For IVI class-compliant drivers, the minor version number of the instrument class specification.  If the driver is not class compliant, the driver returns zero.')], HRESULT, 'SpecificationMinorVersion',
              ( ['out', 'retval'], POINTER(c_int), 'pVal' )),
    COMMETHOD(['propget', helpstring('A comma-separated list of the class capability groups implemented by the driver.  Capability group names are documented in the IVI class specifications.  If the driver is not class compliant, the driver returns an empty string.')], HRESULT, 'GroupCapabilities',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
]
################################################################
## code template for IIviDriverIdentity implementation
##class IIviDriverIdentity_Impl(object):
##    @property
##    def InstrumentManufacturer(self):
##        'The name of the manufacturer reported by the physical instrument.  If Simulation is enabled or the instrument is not capable of reporting the name of the manufacturer, a string is returned that explains the condition. Manufacturer is limited to 256 bytes'
##        #return pVal
##
##    @property
##    def InstrumentModel(self):
##        'The model number or name reported by the physical instrument.  If Simulation is enabled or the instrument is not capable of reporting the model number or name, a string is returned that explains the condition.  Model is limited to 256 bytes'
##        #return pVal
##
##    @property
##    def InstrumentFirmwareRevision(self):
##        'The firmware revision reported by the physical instrument.  If Simulation is enabled or the instrument is not capable of reporting the firmware revision, a string is returned that explains the condition.'
##        #return pVal
##
##    @property
##    def Identifier(self):
##        'The case-sensitive unique identifier of the implementing IVI-COM instrument driver.'
##        #return pVal
##
##    @property
##    def SupportedInstrumentModels(self):
##        'A comma-separated list of instrument models that the IVI specific driver can control.'
##        #return pVal
##
##    @property
##    def SpecificationMajorVersion(self):
##        'For IVI class-compliant drivers, the major version number of the instrument class specification.  If the driver is not class compliant, the driver returns zero.'
##        #return pVal
##
##    @property
##    def SpecificationMinorVersion(self):
##        'For IVI class-compliant drivers, the minor version number of the instrument class specification.  If the driver is not class compliant, the driver returns zero.'
##        #return pVal
##
##    @property
##    def GroupCapabilities(self):
##        'A comma-separated list of the class capability groups implemented by the driver.  Capability group names are documented in the IVI class specifications.  If the driver is not class compliant, the driver returns an empty string.'
##        #return pVal
##

class Library(object):
    'IviDriver 1.0 Type Library'
    name = 'IviDriverLib'
    _reg_typelib_ = ('{47ED5120-A398-11D4-BA58-000064657374}', 1, 0)

class IIviClassWrapper(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    'IVI Driver class wrapper interface'
    _iid_ = GUID('{47ED518A-A398-11D4-BA58-000064657374}')
    _idlflags_ = ['oleautomation']
IIviClassWrapper._methods_ = [
    COMMETHOD([helpstring('Binds a COM wrapper object to an existing IVI-C specific driver session.')], HRESULT, 'AttachToExistingCSession',
              ( ['in'], c_int, 'Vi' )),
    COMMETHOD(['propget', helpstring('The C session handle that the COM wrapper is currently using to communicate with an IVI-C specific driver.')], HRESULT, 'NativeCHandle',
              ( ['out', 'retval'], POINTER(c_int), 'pVal' )),
]
################################################################
## code template for IIviClassWrapper implementation
##class IIviClassWrapper_Impl(object):
##    def AttachToExistingCSession(self, Vi):
##        'Binds a COM wrapper object to an existing IVI-C specific driver session.'
##        #return 
##
##    @property
##    def NativeCHandle(self):
##        'The C session handle that the COM wrapper is currently using to communicate with an IVI-C specific driver.'
##        #return pVal
##

class IIviDriverUtility(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    'IVI Driver utility interface'
    _iid_ = GUID('{47ED5189-A398-11D4-BA58-000064657374}')
    _idlflags_ = ['oleautomation']
IIviDriverUtility._methods_ = [
    COMMETHOD([helpstring('Places the instrument in a known state and configures instrument options on which the IVI specific driver depends (for example, enabling/disabling headers).  For an IEEE 488.2 instrument, Reset sends the command string *RST to the instrument.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring('Does the equivalent of Reset and then, (1) disables class extension capability groups, (2) sets attributes to initial values defined by class specs, and (3) configures the driver to option string settings used when Initialize was last executed.')], HRESULT, 'ResetWithDefaults'),
    COMMETHOD([helpstring('Quickly places the instrument in a state where it has no, or minimal, effect on the external system to which it is connected.  This state is not necessarily a known state.')], HRESULT, 'Disable'),
    COMMETHOD([helpstring("Performs an instrument self test, waits for the instrument to complete the test, and queries the instrument for the results.  If the instrument passes the test, TestResult is zero and TestMessage is 'Self test passed'.")], HRESULT, 'SelfTest',
              ( ['in', 'out'], POINTER(c_int), 'TestResult' ),
              ( ['in', 'out'], POINTER(BSTR), 'TestMessage' )),
    COMMETHOD([helpstring('Queries the instrument and returns instrument specific error information.  This function can be used when QueryInstrumentStatus is True to retrieve error details when the driver detects an instrument error.')], HRESULT, 'ErrorQuery',
              ( ['in', 'out'], POINTER(c_int), 'ErrorCode' ),
              ( ['in', 'out'], POINTER(BSTR), 'ErrorMessage' )),
    COMMETHOD([helpstring('Obtains a multithread lock on the driver after waiting until all other execution threads have released their locks on the instrument session.')], HRESULT, 'LockObject'),
    COMMETHOD([helpstring('Releases a previously obtained mutlithread lock.')], HRESULT, 'UnlockObject'),
]
################################################################
## code template for IIviDriverUtility implementation
##class IIviDriverUtility_Impl(object):
##    def Reset(self):
##        'Places the instrument in a known state and configures instrument options on which the IVI specific driver depends (for example, enabling/disabling headers).  For an IEEE 488.2 instrument, Reset sends the command string *RST to the instrument.'
##        #return 
##
##    def ResetWithDefaults(self):
##        'Does the equivalent of Reset and then, (1) disables class extension capability groups, (2) sets attributes to initial values defined by class specs, and (3) configures the driver to option string settings used when Initialize was last executed.'
##        #return 
##
##    def Disable(self):
##        'Quickly places the instrument in a state where it has no, or minimal, effect on the external system to which it is connected.  This state is not necessarily a known state.'
##        #return 
##
##    def SelfTest(self):
##        "Performs an instrument self test, waits for the instrument to complete the test, and queries the instrument for the results.  If the instrument passes the test, TestResult is zero and TestMessage is 'Self test passed'."
##        #return TestResult, TestMessage
##
##    def ErrorQuery(self):
##        'Queries the instrument and returns instrument specific error information.  This function can be used when QueryInstrumentStatus is True to retrieve error details when the driver detects an instrument error.'
##        #return ErrorCode, ErrorMessage
##
##    def LockObject(self):
##        'Obtains a multithread lock on the driver after waiting until all other execution threads have released their locks on the instrument session.'
##        #return 
##
##    def UnlockObject(self):
##        'Releases a previously obtained mutlithread lock.'
##        #return 
##

class IIviDriverOperation(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    'IVI Driver operation interface'
    _iid_ = GUID('{47ED5188-A398-11D4-BA58-000064657374}')
    _idlflags_ = ['oleautomation']
IIviDriverOperation._methods_ = [
    COMMETHOD(['propget', helpstring('Logical Name identifies a driver session in the Configuration Store.  If Logical Name is not empty, the driver was initialized from information in the driver session.  If it is empty, the driver was initialized without using the Configuration Store.')], HRESULT, 'LogicalName',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
    COMMETHOD(['propget', helpstring('The resource descriptor specifies the connection to a physical device.  It is either specified in the Configuration Store or passed in the ResourceName parameter of the Initialize function.  It is empty if the driver is not initialized.')], HRESULT, 'IoResourceDescriptor',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
    COMMETHOD(['propget', helpstring('If True, the driver caches instrument settings to avoid unnecessary I/O to the instrument.  The actual settings that are cached are driver-specific.')], HRESULT, 'Cache',
              ( ['out', 'retval'], POINTER(VARIANT_BOOL), 'pVal' )),
    COMMETHOD(['propput', helpstring('If True, the driver caches instrument settings to avoid unnecessary I/O to the instrument.  The actual settings that are cached are driver-specific.')], HRESULT, 'Cache',
              ( ['in'], VARIANT_BOOL, 'pVal' )),
    COMMETHOD(['propget', helpstring('If True, the driver maintains a record of interchangeability warnings.  If the driver does not support interchangeability checking, attempts to set InterchangeCheck to True return an error.')], HRESULT, 'InterchangeCheck',
              ( ['out', 'retval'], POINTER(VARIANT_BOOL), 'pVal' )),
    COMMETHOD(['propput', helpstring('If True, the driver maintains a record of interchangeability warnings.  If the driver does not support interchangeability checking, attempts to set InterchangeCheck to True return an error.')], HRESULT, 'InterchangeCheck',
              ( ['in'], VARIANT_BOOL, 'pVal' )),
    COMMETHOD(['propget', helpstring('If True, the driver queries the instrument status at the end of each method or property that performs I/O to the instrument.  If an error is reported, use ErrorQuery to retrieve error messages one at a time from the instrument.')], HRESULT, 'QueryInstrumentStatus',
              ( ['out', 'retval'], POINTER(VARIANT_BOOL), 'pVal' )),
    COMMETHOD(['propput', helpstring('If True, the driver queries the instrument status at the end of each method or property that performs I/O to the instrument.  If an error is reported, use ErrorQuery to retrieve error messages one at a time from the instrument.')], HRESULT, 'QueryInstrumentStatus',
              ( ['in'], VARIANT_BOOL, 'pVal' )),
    COMMETHOD(['propget', helpstring('If True, the driver validates property and parameter values to avoid invalid commands to the instrument.  The extent of the validation is driver-specific.')], HRESULT, 'RangeCheck',
              ( ['out', 'retval'], POINTER(VARIANT_BOOL), 'pVal' )),
    COMMETHOD(['propput', helpstring('If True, the driver validates property and parameter values to avoid invalid commands to the instrument.  The extent of the validation is driver-specific.')], HRESULT, 'RangeCheck',
              ( ['in'], VARIANT_BOOL, 'pVal' )),
    COMMETHOD(['propget', helpstring('If True, the driver keeps a list of the value coercions it makes for ViInt32 and ViReal64 attributes.  If the driver does not support coercion recording, attempts to set RecordCoercions to True will return an error.')], HRESULT, 'RecordCoercions',
              ( ['out', 'retval'], POINTER(VARIANT_BOOL), 'pVal' )),
    COMMETHOD(['propput', helpstring('If True, the driver keeps a list of the value coercions it makes for ViInt32 and ViReal64 attributes.  If the driver does not support coercion recording, attempts to set RecordCoercions to True will return an error.')], HRESULT, 'RecordCoercions',
              ( ['in'], VARIANT_BOOL, 'pVal' )),
    COMMETHOD(['propget', helpstring('If True, the driver does not perform I/O to the instrument, and returns simulated values for output parameters.')], HRESULT, 'Simulate',
              ( ['out', 'retval'], POINTER(VARIANT_BOOL), 'pVal' )),
    COMMETHOD(['propput', helpstring('If True, the driver does not perform I/O to the instrument, and returns simulated values for output parameters.')], HRESULT, 'Simulate',
              ( ['in'], VARIANT_BOOL, 'pVal' )),
    COMMETHOD(['propget', helpstring('The driver setup string.  It is either specified in the Configuration Store or passed in the OptionString parameter of the Initialize function.  Driver setup is empty if the driver is not initialized.')], HRESULT, 'DriverSetup',
              ( ['out', 'retval'], POINTER(BSTR), 'pVal' )),
    COMMETHOD([helpstring("Invalidates all of the driver's cached values.")], HRESULT, 'InvalidateAllAttributes'),
    COMMETHOD([helpstring('Clears the list of interchangeability warnings that the IVI specific driver maintains.')], HRESULT, 'ClearInterchangeWarnings'),
    COMMETHOD([helpstring('Returns the oldest warning from the interchange warning list.  Records are only added to the list if InterchangeCheck is True.')], HRESULT, 'GetNextInterchangeWarning',
              ( ['out', 'retval'], POINTER(BSTR), 'InterchangeWarning' )),
    COMMETHOD([helpstring('Resets the interchangeability checking algorithms of the driver so that methods and properties that executed prior to calling this function have no affect on whether future calls to the driver generate interchangeability warnings.')], HRESULT, 'ResetInterchangeCheck'),
    COMMETHOD([helpstring('Returns the oldest record from the coercion record list.  Records are only added to the list if RecordCoercions is True.')], HRESULT, 'GetNextCoercionRecord',
              ( ['out', 'retval'], POINTER(BSTR), 'CoercionRecord' )),
]
################################################################
## code template for IIviDriverOperation implementation
##class IIviDriverOperation_Impl(object):
##    @property
##    def LogicalName(self):
##        'Logical Name identifies a driver session in the Configuration Store.  If Logical Name is not empty, the driver was initialized from information in the driver session.  If it is empty, the driver was initialized without using the Configuration Store.'
##        #return pVal
##
##    @property
##    def IoResourceDescriptor(self):
##        'The resource descriptor specifies the connection to a physical device.  It is either specified in the Configuration Store or passed in the ResourceName parameter of the Initialize function.  It is empty if the driver is not initialized.'
##        #return pVal
##
##    def _get(self):
##        'If True, the driver caches instrument settings to avoid unnecessary I/O to the instrument.  The actual settings that are cached are driver-specific.'
##        #return pVal
##    def _set(self, pVal):
##        'If True, the driver caches instrument settings to avoid unnecessary I/O to the instrument.  The actual settings that are cached are driver-specific.'
##    Cache = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        'If True, the driver maintains a record of interchangeability warnings.  If the driver does not support interchangeability checking, attempts to set InterchangeCheck to True return an error.'
##        #return pVal
##    def _set(self, pVal):
##        'If True, the driver maintains a record of interchangeability warnings.  If the driver does not support interchangeability checking, attempts to set InterchangeCheck to True return an error.'
##    InterchangeCheck = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        'If True, the driver queries the instrument status at the end of each method or property that performs I/O to the instrument.  If an error is reported, use ErrorQuery to retrieve error messages one at a time from the instrument.'
##        #return pVal
##    def _set(self, pVal):
##        'If True, the driver queries the instrument status at the end of each method or property that performs I/O to the instrument.  If an error is reported, use ErrorQuery to retrieve error messages one at a time from the instrument.'
##    QueryInstrumentStatus = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        'If True, the driver validates property and parameter values to avoid invalid commands to the instrument.  The extent of the validation is driver-specific.'
##        #return pVal
##    def _set(self, pVal):
##        'If True, the driver validates property and parameter values to avoid invalid commands to the instrument.  The extent of the validation is driver-specific.'
##    RangeCheck = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        'If True, the driver keeps a list of the value coercions it makes for ViInt32 and ViReal64 attributes.  If the driver does not support coercion recording, attempts to set RecordCoercions to True will return an error.'
##        #return pVal
##    def _set(self, pVal):
##        'If True, the driver keeps a list of the value coercions it makes for ViInt32 and ViReal64 attributes.  If the driver does not support coercion recording, attempts to set RecordCoercions to True will return an error.'
##    RecordCoercions = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        'If True, the driver does not perform I/O to the instrument, and returns simulated values for output parameters.'
##        #return pVal
##    def _set(self, pVal):
##        'If True, the driver does not perform I/O to the instrument, and returns simulated values for output parameters.'
##    Simulate = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def DriverSetup(self):
##        'The driver setup string.  It is either specified in the Configuration Store or passed in the OptionString parameter of the Initialize function.  Driver setup is empty if the driver is not initialized.'
##        #return pVal
##
##    def InvalidateAllAttributes(self):
##        "Invalidates all of the driver's cached values."
##        #return 
##
##    def ClearInterchangeWarnings(self):
##        'Clears the list of interchangeability warnings that the IVI specific driver maintains.'
##        #return 
##
##    def GetNextInterchangeWarning(self):
##        'Returns the oldest warning from the interchange warning list.  Records are only added to the list if InterchangeCheck is True.'
##        #return InterchangeWarning
##
##    def ResetInterchangeCheck(self):
##        'Resets the interchangeability checking algorithms of the driver so that methods and properties that executed prior to calling this function have no affect on whether future calls to the driver generate interchangeability warnings.'
##        #return 
##
##    def GetNextCoercionRecord(self):
##        'Returns the oldest record from the coercion record list.  Records are only added to the list if RecordCoercions is True.'
##        #return CoercionRecord
##


# values for enumeration 'IviDriver_ErrorCodes'
S_IVI_SUCCESS = 0
E_IVI_CANNOT_RECOVER = -2147192832
E_IVI_INSTRUMENT_STATUS = -2147192831
E_IVI_CANNOT_OPEN_FILE = -2147192830
E_IVI_READING_FILE = -2147192829
E_IVI_WRITING_FILE = -2147192828
E_IVI_INVALID_PATHNAME = -2147192821
E_IVI_INVALID_VALUE = -2147192816
E_IVI_METHOD_NOT_SUPPORTED = -2147192815
E_IVI_PROPERTY_NOT_SUPPORTED = -2147192814
E_IVI_VALUE_NOT_SUPPORTED = -2147192813
E_IVI_NOT_INITIALIZED = -2147192803
E_IVI_UNKNOWN_CHANNEL_NAME = -2147192800
E_IVI_TOO_MANY_OPEN_FILES = -2147192797
E_IVI_CHANNEL_NAME_REQUIRED = -2147192764
E_IVI_MISSING_OPTION_NAME = -2147192759
E_IVI_MISSING_OPTION_VALUE = -2147192758
E_IVI_BAD_OPTION_NAME = -2147192757
E_IVI_BAD_OPTION_VALUE = -2147192756
E_IVI_OUT_OF_MEMORY = -2147192746
E_IVI_OPERATION_PENDING = -2147192745
E_IVI_NULL_POINTER = -2147192744
E_IVI_UNEXPECTED_RESPONSE = -2147192743
E_IVI_FILE_NOT_FOUND = -2147192741
E_IVI_INVALID_FILE_FORMAT = -2147192740
E_IVI_STATUS_NOT_AVAILABLE = -2147192739
E_IVI_ID_QUERY_FAILED = -2147192738
E_IVI_RESET_FAILED = -2147192737
E_IVI_RESOURCE_UNKNOWN = -2147192736
E_IVI_ALREADY_INITIALIZED = -2147192735
E_IVI_CANNOT_CHANGE_SIMULATION_STATE = -2147192734
E_IVI_INVALID_NUMBER_OF_LEVELS_IN_SELECTOR = -2147192733
E_IVI_INVALID_RANGE_IN_SELECTOR = -2147192732
E_IVI_UNKNOWN_NAME_IN_SELECTOR = -2147192731
E_IVI_BADLY_FORMED_SELECTOR = -2147192730
E_IVI_UNKNOWN_PHYSICAL_IDENTIFIER = -2147192729
S_IVI_NSUP_ID_QUERY = 290917
S_IVI_NSUP_RESET = 290918
S_IVI_NSUP_SELF_TEST = 290919
S_IVI_NSUP_ERROR_QUERY = 290920
S_IVI_NSUP_REV_QUERY = 290921
IviDriver_ErrorCodes = c_int # enum
class IIviDriver(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    'IVI Driver root interface'
    _iid_ = GUID('{47ED5184-A398-11D4-BA58-000064657374}')
    _idlflags_ = ['oleautomation']
IIviDriver._methods_ = [
    COMMETHOD(['propget', helpstring('Pointer to the IIviDriverOperation interface')], HRESULT, 'DriverOperation',
              ( ['out', 'retval'], POINTER(POINTER(IIviDriverOperation)), 'pVal' )),
    COMMETHOD(['propget', helpstring('Pointer to the IIviDriverIdentity interface')], HRESULT, 'Identity',
              ( ['out', 'retval'], POINTER(POINTER(IIviDriverIdentity)), 'pVal' )),
    COMMETHOD(['propget', helpstring('Pointer to the IIviDriverUtility interface')], HRESULT, 'Utility',
              ( ['out', 'retval'], POINTER(POINTER(IIviDriverUtility)), 'pVal' )),
    COMMETHOD([helpstring('Opens the I/O session to the instrument.  Driver methods and properties that access the instrument are only accessible after Initialize is called.  Initialize optionally performs a Reset and queries the instrument to validate the instrument model.')], HRESULT, 'Initialize',
              ( ['in'], BSTR, 'ResourceName' ),
              ( ['in'], VARIANT_BOOL, 'IdQuery' ),
              ( ['in'], VARIANT_BOOL, 'Reset' ),
              ( ['in', 'optional'], BSTR, 'OptionString' )),
    COMMETHOD(['propget', helpstring('Initialized is True between a successful call to the Initialize method and a successful call to the Close method, and False at all other times.')], HRESULT, 'Initialized',
              ( ['out', 'retval'], POINTER(VARIANT_BOOL), 'pVal' )),
    COMMETHOD([helpstring('Closes the I/O session to the instrument.  Driver methods and properties that access the instrument are not accessible after Close is called.')], HRESULT, 'Close'),
]
################################################################
## code template for IIviDriver implementation
##class IIviDriver_Impl(object):
##    @property
##    def DriverOperation(self):
##        'Pointer to the IIviDriverOperation interface'
##        #return pVal
##
##    @property
##    def Identity(self):
##        'Pointer to the IIviDriverIdentity interface'
##        #return pVal
##
##    @property
##    def Utility(self):
##        'Pointer to the IIviDriverUtility interface'
##        #return pVal
##
##    def Initialize(self, ResourceName, IdQuery, Reset, OptionString):
##        'Opens the I/O session to the instrument.  Driver methods and properties that access the instrument are only accessible after Initialize is called.  Initialize optionally performs a Reset and queries the instrument to validate the instrument model.'
##        #return 
##
##    @property
##    def Initialized(self):
##        'Initialized is True between a successful call to the Initialize method and a successful call to the Close method, and False at all other times.'
##        #return pVal
##
##    def Close(self):
##        'Closes the I/O session to the instrument.  Driver methods and properties that access the instrument are not accessible after Close is called.'
##        #return 
##

__all__ = [ 'E_IVI_STATUS_NOT_AVAILABLE', 'S_IVI_NSUP_ERROR_QUERY',
           'E_IVI_UNKNOWN_NAME_IN_SELECTOR',
           'E_IVI_UNKNOWN_PHYSICAL_IDENTIFIER', 'E_IVI_NULL_POINTER',
           'E_IVI_INVALID_VALUE', 'E_IVI_UNKNOWN_CHANNEL_NAME',
           'IIviDriverIdentity', 'E_IVI_CANNOT_OPEN_FILE',
           'IIviDriver', 'E_IVI_INSTRUMENT_STATUS',
           'E_IVI_UNEXPECTED_RESPONSE', 'E_IVI_ID_QUERY_FAILED',
           'E_IVI_TOO_MANY_OPEN_FILES',
           'E_IVI_PROPERTY_NOT_SUPPORTED', 'E_IVI_OUT_OF_MEMORY',
           'E_IVI_READING_FILE', 'E_IVI_INVALID_FILE_FORMAT',
           'E_IVI_BAD_OPTION_VALUE', 'E_IVI_VALUE_NOT_SUPPORTED',
           'E_IVI_MISSING_OPTION_NAME', 'E_IVI_FILE_NOT_FOUND',
           'S_IVI_NSUP_RESET', 'S_IVI_NSUP_SELF_TEST',
           'E_IVI_CHANNEL_NAME_REQUIRED', 'E_IVI_BAD_OPTION_NAME',
           'E_IVI_OPERATION_PENDING', 'E_IVI_METHOD_NOT_SUPPORTED',
           'IIviComponentIdentity',
           'E_IVI_CANNOT_CHANGE_SIMULATION_STATE',
           'E_IVI_RESET_FAILED', 'S_IVI_NSUP_REV_QUERY',
           'E_IVI_MISSING_OPTION_VALUE',
           'E_IVI_INVALID_NUMBER_OF_LEVELS_IN_SELECTOR',
           'IviDriver_ErrorCodes', 'S_IVI_NSUP_ID_QUERY',
           'IIviClassWrapper', 'E_IVI_RESOURCE_UNKNOWN',
           'IIviDriverOperation', 'E_IVI_INVALID_RANGE_IN_SELECTOR',
           'E_IVI_NOT_INITIALIZED', 'E_IVI_CANNOT_RECOVER',
           'S_IVI_SUCCESS', 'E_IVI_BADLY_FORMED_SELECTOR',
           'E_IVI_WRITING_FILE', 'E_IVI_INVALID_PATHNAME',
           'E_IVI_ALREADY_INITIALIZED', 'IIviDriverUtility']
from comtypes import _check_version; _check_version('')
